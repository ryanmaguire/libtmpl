"""
################################################################################
#                                   LICENSE                                    #
################################################################################
#   This file is part of libtmpl.                                              #
#                                                                              #
#   libtmpl is free software: you can redistribute it and/or modify it         #
#   under the terms of the GNU General Public License as published by          #
#   the Free Software Foundation, either version 3 of the License, or          #
#   (at your option) any later version.                                        #
#                                                                              #
#   libtmpl is distributed in the hope that it will be useful,                 #
#   but WITHOUT ANY WARRANTY; without even the implied warranty of             #
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              #
#   GNU General Public License for more details.                               #
#                                                                              #
#   You should have received a copy of the GNU General Public License          #
#   along with libtmpl.  If not, see <https://www.gnu.org/licenses/>.          #
################################################################################
#   Purpose:                                                                   #
#       Taylor and branch coefficients for the Lambert W function.             #
################################################################################
#   Author: Ryan Maguire                                                       #
#   Date:   January 23, 2023.                                                  #
################################################################################
"""

# Arbitrary precision rationals here.
import fractions

# Factorial functions.
import math

# Multi-precision math routines.
import mpmath
mpmath.mp.dps = 224

# Compute the nth Taylor coefficient of LambertW(x).
def taylor(n):
    if n == 0:
        return fractions.Fraction(0, 1)

    num = (-n)**(n-1)
    den = math.factorial(n)
    return fractions.Fraction(num, den)

# Following Corless, Gonnet, Hare, Jeffrey, and Knuth, define the mu function
# recursively. The alpha function is given below. The first few entries are
# given to high precision. The recursion is very long for even moderately sized
# n, such as n = 20 or so.
def mu(n):
    data = [
        mpmath.mpf('-1.0'),
        mpmath.mpf('1.0'),
        mpmath.mpf('-0.33333333333333333333333333333333333333333333333333333333333333333334'),
        mpmath.mpf('0.152777777777777777777777777777777777777777777777777777777777777777774'),
        mpmath.mpf('-0.0796296296296296296296296296296296296296296296296296296296296296296293'),
        mpmath.mpf('0.0445023148148148148148148148148148148148148148148148148148148148148142'),
        mpmath.mpf('-0.0259847148736037624926513815402704291593180482069370958259847148736043'),
        mpmath.mpf('0.0156356325323339212228101116990005878894767783656672545561434450323335'),
        mpmath.mpf('-0.00961689202429943170683911424652165392906133646874387615128355869096609'),
        mpmath.mpf('0.00601454325295611786095325189975395736712609140592679687329893091209975'),
        mpmath.mpf('-0.00381129803489199922670430215011833667526397293201134079049031038057107'),
        mpmath.mpf('0.00244087799114398266589685852864375302156999197955498171057645876379957'),
        mpmath.mpf('-0.00157693034468678425392340953993141159731618503147233523700525681930955'),
        mpmath.mpf('0.00102626332050760715443754815339068610564680414659729659620791199165579'),
        mpmath.mpf('-0.000672061631156136204002020043419075215912225369262261141402677608685693'),
        mpmath.mpf('0.000442473061814620909930207608584737264792328020688002591651619214684269'),
        mpmath.mpf('-0.000292677224729627444849929040814492524347154949417023106259338610667932'),
        mpmath.mpf('0.00019438727605453931782225910504966719735095882655619517561029080707487'),
        mpmath.mpf('-0.000129574266852748818882408573478882443559188763747300904743350446469408'),
        mpmath.mpf('0.0000866503580520812716604515904623902931905978277832884914847997401168911'),
        mpmath.mpf('-0.0000581136075044138167722054647788281772566118442219128814564142535396325'),
        mpmath.mpf('0.0000390766848674390516353955830445274921321091605535929048840017348475696'),
        mpmath.mpf('-0.0000263380647472310987385840827186494430787039822172190750564283365251091'),
        mpmath.mpf('0.0000177903458050795854007362820751845403832744604641694900585742112076762')
    ]

    # Use the lookup table for small n.
    if n < len(data):
        return data[n]

    # Use Eqn 4.23 of Corless, Gonnet, Hare, Jeffrey, and Knuth.
    a = mpmath.mpf(n-1) / mpmath.mpf(n+1)
    b = mu(n-2)/mpmath.mpf(2)
    c = alpha(n-2)/mpmath.mpf(4)
    d = alpha(n)/mpmath.mpf(2)
    e = mu(n-1)/mpmath.mpf(n+1)
    return a*(b + c) - d - e

# The alpha function that is used to compute the coefficients of the branch cut
# expansion. Like the mu function this is defined recursively.
def alpha(k):

    # Lookup table of the first few entries.
    data = [
        mpmath.mpf('2.0'),
        mpmath.mpf('-1.0'),
        mpmath.mpf('0.0'),
        mpmath.mpf('0.11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111092'),
        mpmath.mpf('-0.10185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185185182'),
        mpmath.mpf('0.076427469135802469135802469135802469135802469135802469135802469135802469135802469135802469135802469135802469135802469135802469135802469135802469135802469135802469135802469135802469135802469135802469135802469135802469135802469173'),
        mpmath.mpf('-0.053999485596707818930041152263374485596707818930041152263374485596707818930041152263374485596707818930041152263374485596707818930041152263374485596707818930041152263374485596707818930041152263374485596707818930041152263374485551'),
        mpmath.mpf('0.03726195069077013521457965902410346854791299235743680188124632569077013521457965902410346854791299235743680188124632569077013521457965902410346854791299235743680188124632569077013521457965902410346854791299235743680188124632567'),
        mpmath.mpf('-0.025450934703442419491802207851590567639950355999738715788098504147886863936246652296035012084394800444183160232542948592331308380691096740479456528839244888627604676987393036775752825135541184923900973283689333072049121431837468'),
        mpmath.mpf('0.017307578201122841683541272018638273782306704117403705881072136216169137979837568314934570078603000413700002177368432512465434276133864611230866374899296709996298473664728808761730572430160907527162671195593006292594769961025078'),
        mpmath.mpf('-0.011751069465679456891733983640705177056343037138647563887618757303256617385561144134532337550170197632474724381445917797083777879388304628359498043997358126301884875273078290910938373215465122186658537824518620129045369100238743'),
        mpmath.mpf('0.007977070651458650124926906558626461951303547750082468222124633385982918937390163466327814097100137991117153701254556960350937749853420374029166242896728232151839180384480534718956562316677281730518388693318473186524659514404084'),
        mpmath.mpf('-0.0054182098050369676252361002072500755192853522811935074874086784292110135296060786513025936458775529474682478362231013177079761006427237620217784391364202804096548517041908728716053383460355394076298990619542800177285338519470934'),
        mpmath.mpf('0.0036836748226885900659942294628862443002273603009553539742753059538392784631380664215380177668156417040515718853080318013799408186152367135231245667372564404811231296740909822539365074257403388415646999922045102440077073734834934'),
        mpmath.mpf('-0.0025072757279999742035902313580295304916261361634816610466373496109091002436238717003118480825857024316899045635228418050432696864352898203719434513230464776759258581861117769552169070244857182098165978381683014397249306271595184'),
        mpmath.mpf('0.0017086497206356896196451673124874920961947958897223793447994656192206410790008431676489439654655952016739546708603883879623398618518893931807662051067648839959003672916815270744090150733059890829588151183049366882164340933450346'),
        mpmath.mpf('-0.0011658478182449269577599919803520197428035758544849173259591771693389593339629070360252568779258765656549210689591968693390630181739790581887938366813342433152246355923735358294665260182080468426306190699488874658280258587071674'),
        mpmath.mpf('0.00079645440364529394245239947428314994168307819953322756196499114196411898010258041985832238055481480591010065366301601399018727800379987561637455568319398701233714174840241498998498536427628518475744746037260558503506543683661914'),
        mpmath.mpf('-0.00054474587827316680113272199709159696143077755441716558147552773521302814809242352380368214828981846276298382054770400754730096754156828705219999999999999999999999999999999999999999999999999999999999999999999999999999999999999952'),
        mpmath.mpf('0.00037300974067057999871095063439522560934797135449868116843824330466435936275451335992252107671885593489024093395468671665016824327687973502350000000000000000000000000000000000000000000000000000000000000000000000000000000000000004'),
        mpmath.mpf('-0.00025569171974838544801975692993728260489621292744800124647339870471485438297575457817194055053687412013755312760097501831963909903323925315420000000000000000000000000000000000000000000000000000000000000000000000000000000000000051'),
        mpmath.mpf('0.0001754526203904061264502519740362958480905495783971963391861445464894664302886464527258834516868678452903188225572248361568396436843755032054399999999999999999999999999999999999999999999999999999999999999999999999999999999999999'),
        mpmath.mpf('-0.0001205109220136080399008559080751321598453443306947518241620732918860123396458702936055265280851646533792254550020280304702617409122711708971799999999999999999999999999999999999999999999999999999999999999999999999999999999999999'),
        mpmath.mpf('0.000082850225926198692715554215300304170985945031529271094408205113046362616503695019339534858125125257106656624901906806288786170978549717602720000000000000000000000000000000000000000000000000000000000000000000000000000000000000163')
    ]

    # Use the lookup table for small values.
    if k < len(data):
        return data[k]

    # Compute the sum in Eqn 4.24 of Corless, Gonnet, Hare, Jeffrey, and Knuth.
    out = mpmath.mpf(0)
    for j in range(2, k):
        out += mu(j)*mu(k + 1 - j)

    return out

# The coefficients in Corless, Gonnet, Hare, Jeffrey, and Knuth are just mu(k).
# However the near-branch function computes in terms of sqrt(x + 1/e) instead
# of sqrt(2(1+ex)) like is done in their paper. This means we have an extra
# sqrt(2e)^n for the nth coefficient.
def branch_series(k):
    a = mpmath.sqrt(mpmath.mpf(2)*mpmath.e)
    return a**k * mu(k)
