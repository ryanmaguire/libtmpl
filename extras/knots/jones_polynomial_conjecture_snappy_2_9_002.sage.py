"""
################################################################################
#                                  LICENSE                                     #
################################################################################
#   This file is part of libtmpl.                                              #
#                                                                              #
#   libtmpl is free software: you can redistribute it and/or modify it         #
#   under the terms of the GNU General Public License as published by          #
#   the Free Software Foundation, either version 3 of the License, or          #
#   (at your option) any later version.                                        #
#                                                                              #
#   libtmpl is distributed in the hope that it will be useful,                 #
#   but WITHOUT ANY WARRANTY; without even the implied warranty of             #
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              #
#   GNU General Public License for more details.                               #
#                                                                              #
#   You should have received a copy of the GNU General Public License          #
#   along with libtmpl.  If not, see <https://www.gnu.org/licenses/>.          #
################################################################################
#   Purpose:                                                                   #
#       Test a conjecture about Khovanov homology and the Jones' polynomial.   #
#       The idea is that Khovanov homology can distinguish a Torus knot from   #
#       a non-torus knot. First, see if this is true of the Jones' polynomial. #
#       If we find a match, compute (currently by hand or lookup table) the    #
#       Khovanov homologies of the matching pair to see if they're the same.   #
#       This is the same as jones_polynomial_conjecture_snappy_2_9_001.sage,   #
#       except that the torus knot Jones' polynomials are computed via         #
#       a known formula, rather than using SnapPy to directly compute the      #
#       polynomial. This hugely saves on computation time.                     #
#                                                                              #
#       This code works with SnapPy versions less than 3.0. Snappy 3.0 and     #
#       higher changed how the Jones' polynomial function works.               #
################################################################################
#   Author: Ryan Maguire                                                       #
#   Date:   June 12, 2021.                                                     #
################################################################################
"""

# This file was *autogenerated* from the file jones_polynomial_conjecture_snappy_2_9_002.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_368 = Integer(368); _sage_const_186 = Integer(186); _sage_const_100 = Integer(100); _sage_const_12 = Integer(12)
# The SnapPy module will be used for most of the computations with knots.
import snappy

# Numpy is needed for it's GCD function.
import numpy

# Largest number of twists we'll check for torus knots.
torus_start = _sage_const_2 
torus_end = _sage_const_100 
torus_count = _sage_const_0 

# Generate the ring of Laurent polynomials in variable over Q (rationals).
R = LaurentPolynomialRing(QQ, names=('q',)); (q,) = R._first_ngens(1)

# Create two empty lists for storing the knots and their Jones' polynomials.
KnotList = []
MirrorList = []
TorusStringList = []

# Loop over and compute the Jones' Polynomial of torus knows.
for m in range(torus_start, torus_end):

    # There are no torus knots with m or n equal to 0. The torus knots with
    # m or n equal +/- 1 are actually trivial knots, so skip.
    if (m == _sage_const_0 ) or (m == _sage_const_1 ) or (m == -_sage_const_1 ):
        continue

    # The torus knot T(m,n) and T(m,n) are the same. Because of this we can cut
    # the square lattice [-N, -N] x [N, N] in half and compute the upper
    # triangle. This saves us from redundant computations.
    for n in range(m+_sage_const_1 , torus_end):

        # Same skip as before.
        if (n == _sage_const_0 ) or (n == _sage_const_1 ) or (n == -_sage_const_1 ):
            continue

        # We only perform the computation if p and q are coprime. Otherwise we
        # have a link, several intertwined knots.
        if (numpy.gcd(m, n) != _sage_const_1 ):
            continue

        f = q**((m-_sage_const_1 )*(n-_sage_const_1 )//_sage_const_2 )*(_sage_const_1 -q**(m+_sage_const_1 )-q**(n+_sage_const_1 )+q**(m+n)) / (_sage_const_1 -q**_sage_const_2 )
        g = q**((_sage_const_1 -m)*(n-_sage_const_1 )//_sage_const_2 )*(_sage_const_1 -q**(-m-_sage_const_1 )-q**(-n-_sage_const_1 )+q**(-m-n))/(_sage_const_1 -q**(-_sage_const_2 ))

        # Add the two knots to our lists.
        KnotList.append(f)
        MirrorList.append(g)
        TorusStringList.append("(%d, %d)" % (m, n))
        torus_count += _sage_const_1 

# The SnapPy module has 367 alternating Hoste-Thistlethwaite knots
# and 185 non-alternating Hoste-Thistlethwaite knots. We can loop over these
# with strings.

# The syntax for manipulating strings in Sage comes from Python, which is
# borrowed from the syntax used in C. We use %d to indicate a placeholder for
# and integer, and then pass an integer to that placeholder via % n, where n is
# and actual integer. We surround the string with quotation marks.

# As a side note, the range function (which is from Python) has syntanx
# range(m,n) and creates an iterator between m and n-1. That is, n is NOT
# included. Hence the need to iterate between 1 and 368 for the alternating and
# 1 and 186 for the non-alternating.

# These are all of the alternating Hoste-Thistlethwaite knots available:
print("\nProcessing Hoste-Thistlethwaite Alternating Table:")
for n in range(_sage_const_1 , _sage_const_368 ):
    knot_string = "K11a%d" % n
    knot = snappy.Link(knot_string)
    f = knot.jones_polynomial()

    for n in range(torus_count):
        tstring = TorusStringList[n]
        if (f == KnotList[n]):
            print("\t%s matches a torus knot: %s" % (knot_string, tstring))
        elif (f == MirrorList[n]):
            print("\t%s matches a torus knot mirror: %s"%(knot_string,tstring))
        else:
            pass

# And these are the non-alternating ones.
print("\nProcessing Hoste-Thistlethwaite Non-Alternating Table:")
for n in range(_sage_const_1 , _sage_const_186 ):
    knot_string = "K11n%d" % n
    knot = snappy.Link(knot_string)
    f = knot.jones_polynomial()

    for n in range(torus_count):
        tstring = TorusStringList[n]
        if (f == KnotList[n]):
            print("\t%s matches a torus knot: %s" % (knot_string, tstring))
        elif (f == MirrorList[n]):
            print("\t%s matches a torus knot mirror: %s"%(knot_string, tstring))
        else:
            pass

# SnapPy has the Rolfsen table for many knots, the highest being 11 crossings.
# Loop between 3 (Trefoil) and 11.
print("\nProcessing Rolfsen Table:")
for k in range(_sage_const_3 , _sage_const_12 ):

    # Reset m to one.
    m = _sage_const_1 

    # If the knot k_n does not exist (for example, "3_5"), and we try to
    # create it, Python will produce an error, crashing the program.
    # Perform this loop in a try-except block to catch any exception raised
    # by the SnapPy module.
    try:
        while(_sage_const_1 ):
            knot_string = ("%d_%d" % (k, m))
            knot = snappy.Link(knot_string)
            f = knot.jones_polynomial()

            for n in range(torus_count):
                tstring = TorusStringList[n]
                if (f == KnotList[n]):
                    print("\t%s matches a torus knot: %s"
                          % (knot_string, tstring))
                elif (f == MirrorList[n]):
                    print("\t%s matches a torus knot mirror: %s"
                          % (knot_string, tstring))
                else:
                    pass

            # Increment m.
            m += _sage_const_1 

    # SnapPy raises an IOError on failure. Try to catch this to prevent error.
    except (IOError, ValueError):
        continue

