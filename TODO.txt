Add polynomial library.
	Have a polynomial be a struct with an unsigned integer pointer
	and an unsigned int. The int is the degree, the pointer is the
	coefficients. Similarly for double and complex pointers.

	Implement root finding algorithm for polynomial from that MIT paper.

	Implement eval function for polynomials.

	For Z[x]:
		Polynomial subtraction.
		Function for if a polynomial divides another.
		Polynomial equality.
		Polynomial comparison.
		Derivative.
		Polynomial eval.
		Set term
		extract term

	For Q[x]:
		Polynomial add
		polynomial subtract
		polynomial multiply
		equality
		Derivative
		polynomial eval
		GCD function.
		Bezout function: ap + bq = GCD(p,q)
		quotient and remainder: a = qb + r
		print
		get string
		Destroy
		Create zero
		Create empty
		Set term
		Extract term

	For Mat[Q[x], N]:
		Smith-Normal Form.
		Determinant.

More functions for complex library:

	complex_sqrt_real
		sqrt of real number, allowing negative real numbers.

	complex_log10
	complex_logb
		complex log in different bases.

	complex_sec/complex_csc/complex_cot.
		Additional complex trig functions.

		Also add inverse trig functions.

	Hyperbolic trig functions for complex arguments.
	Inverse hyperbolic trig functions as well.

	Various powers of small exponent:
		square, cube, fourth power, etc.


Add these bacK;
extern tmpl_ComplexDouble
tmpl_PoincareDiskMobiusTransform(tmpl_ComplexDouble z, tmpl_ComplexDouble w);

extern tmpl_ComplexDouble
tmpl_PoincareDiskInverseMobiusTransform(tmpl_ComplexDouble z,
										tmpl_ComplexDouble w);
